#!/usr/local/bin/node
// @flow

const child_process = require('child_process');
const path = require('path');
const fuzzy = require('fuzzy');

const REPO_ROOT = '/Users/orvar.segerstrom/develop/client_clearing';
const MGMT_ROOT = path.join(REPO_ROOT, 'minium/mgmt');

const shell = (command, cwd = null) => () => {
  console.log(`Running '${command}'`);
  const options = { stdio: 'inherit' };
  if (cwd != null) {
    options.cwd = cwd;
  }

  child_process.execSync(command, options);
};

const getPodByIdentifier = (identifier, callback) => {
  const pods = child_process
    .execSync('kubectl get pods')
    .toString()
    .split('\n')
    .slice(1)
    .map(line => line.split(/ +/))
    .map(([name, _, status]) => ({ name, status }));
  const matchingPods = pods.filter(pod => pod.name.includes(identifier));
  if (matchingPods.length === 0) {
    console.error(`'${identifier}' did not match any pods`);
  } else if (matchingPods.length > 1) {
    console.error(`Ambigious identifier '${identifier}' matched all these:`);
    matchingPods.forEach(pod => console.error(`* '${pod.name}'`));
  } else {
    const pod = matchingPods[0];
    if (pod.status != 'Running') {
      console.log(`Pod ${pod.name} not ready: ${pod.status}`);
      setTimeout(() => getPodByIdentifier(identifier, callback), 1000);
    } else {
      callback(pod.name);
    }
  }
};

const getContainerByPodName = (podName, callback) => {
  return child_process
    .execSync(
      `kubectl get pods ${podName} -o jsonpath='{.spec.containers[*].name}'`
    )
    .toString()
    .split(/[ \n\r\t]+/)
    .map(c => c.trim())
    .filter(c => c.length > 0);
};

const portForward = args => {
  const [identifier] = args;
  getPodByIdentifier(identifier, pod =>
    shell(`kubectl port-forward ${pod} 5005:5005`)()
  );
};

const logs = args => {
  const identifier = args.find(a => !a.startsWith('-'));

  getPodByIdentifier(identifier, pod => {
    const containerNames = getContainerByPodName(pod);
    const extraArgs = args.filter(a => a != identifier);
    console.log(containerNames);
    shell(
      `kubectl logs ${(extraArgs || []).join(' ')} ${pod} -c '${
        containerNames[0]
      }'`
    )();
  });
};

const wait = args => {
  const [identifier] = args;
  getPodByIdentifier(identifier, pod => console.log('Pod ready:', pod));
};

const changeCluster = args => {
  const [search] = args;
  if (search == null) {
    shell(`./which_cluster_am_i_on.sh`, MGMT_ROOT)();
    return;
  }
  const clusters = [2, 3, 4].map(x => `mincluster${x}`);
  const matching = clusters.find(c => fuzzy.match(search, c) != null);
  if (matching == null) {
    console.error(`No cluster for search '${search}'`);
    return;
  }
  shell(`./select_cluster.sh ${matching}`, MGMT_ROOT)();
};

const nukeCluster = args => {
  shell(
    `fish -c '
      ./cluster_purge_all.sh;
      and ./cluster_setup_all.sh;
      and sleep 40;
      and kube wait api;
      and ./load_reference_data.sh;
      and say bid aboop mother fucker;
      and say Cluster (./which_cluster_am_i_on.sh | sed s/mincluster//), is ready for business;

      or say what the fuck;
    '`
      .replace(/\n( )*/g, ' ')
      .trim(),
    MGMT_ROOT
  )();
  /*
  	
  */
};

const actions = {
  pods: shell('kubectl get pods'),
  forward: portForward,
  logs: logs,
  wait: wait,
  c: changeCluster,
  cluster: changeCluster,
  nuke: nukeCluster,
};

const actionName = process.argv[2];
const action = actions[actionName && actionName.toLowerCase()];
if (action == null) {
  if (actionName != null) {
    console.error('Could not find command: ', actionName);
  }
  console.log('Available actions:');
  Object.keys(actions).forEach(k => console.log(`* ${k}`));
  return 1;
}

action(process.argv.slice(3));
